# Timur Query UI

## Status

Completed

## Context

Users would like to make complex "join" queries that combine data from across multiple models in Timur. This includes filters on different models as well as extracting data from different models into a single, combined data frame.

Users need a user interface to make these queries, since manually constructing `/query` requests is confusing and essentially impossible for almost all users.

We also need to add some missing features to the `/query` API so that users can answer a larger set of interesting questions. Namely `::any` and `::every` verbs on `ModelPredicate`.

Note that the `/query` API is actually capable of supporting much more complicated queries, and the Timur UI only lets the user generate a subset of possible queries. We are limited at this point by how much complexity we can squeeze into the UI and the overall user experience (UX) of the Query page.

## Decision

- Create a UI page in Timur to allow construction of queries, using user-friendly inputs (i.e. dropdowns, pre-populated text fields, etc.).
- Pre-populate all selection inputs when possible. I.e. only render the attributes for a selected model, only render viable operator options for a filter, and pre-populate existing values for a table `name` attribute. This helps remove user confusion and complexity around how to construct a query.
- Currently the UI components exist in `timur/lib/client/jsx`, but re-using them in Vulcan might be useful.

### UX Complexity

- The Timur Query UI will have to support the currently known, reasonable set of questions and queries that have been generated by data scientists and collaborators. Even though the API can support more, we will not build additional UI widgets until explicitly necessary.

### Or Filters

- The filters are all default "AND"ed together, and to "OR" some, you can check the leading checkboxes in the filter elements (at least two).

### New `/query` Features

- Add features to the `/query` API to allow selecting `::every` and `::any` verbs for model predicates.
- Implemented using new `Magma::Subquery` classes.

### Contexts

- There are three separate React contexts for different parts of the form. This is to minimize component re-renders (each component that calls `useContext` for a given context will re-render when that context updates, even if the data pulled out by the specific component does not change). This is especially important due to the URL-sync feature, which updates a lot of context information. With only a single context, we had degraded initial page render performance, due to many re-renders across the entire page. [Some guidance on using multiple contexts can be found in this blog post](https://blog.logrocket.com/pitfalls-of-overusing-react-context/).

### Saved Queries

- Save a query state in the URL as URL query params, for simplicity and to not stand up a database. Users can bookmark queries to save them, or e-mail them to each other or to the DL team for collaboration.

## Consequences

- In order to use the same UI components in Vulcan, the current components should be moved to `etna/packages/etna-js`. They could then be re-used in Vulcan to create a query-editing UI. Some progress on this can be seen in [this github branch](https://github.com/mountetna/monoetna/tree/cs/vulcan-edit-query-widget).

### Or Filters

- I'm pretty sure there are much more intuitive ways to let users select how to "OR" filters together -- this should be changed! I'm pretty sure the checkboxes are unintuitive...

### Saved Queries

- URLs are unwieldy since they contain all data to reconstruct a query. Though they are not meant to be human-readable, they are quite long and ugly looking.
- Changes to the client-side application's context or data-storage structure require URL-type migrations and backwards-compatibility for existing, saved URLs.
- No centralized "saved queries" to share with other users. All saving is done client-side. This makes it harder to store and share project-wide queries.
