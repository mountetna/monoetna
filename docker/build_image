#! /usr/bin/env bash
set -e

prog=$0
error() {
   echo "Whoops!  Looks like $1:$2 failed."
   echo "Please try rerunning $prog again."
   exit 1
}
trap 'error "${BASH_SOURCE}" "${LINENO}"' ERR

SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" 
done
DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

function usage() {
  echo "$0 [-f] [-d] <Dockerfile> [<dep> [<dep2> ...]]" 1>&2
}

force=${FORCE_BUILD-:}
digestOnly=
if [[ "$1" == "-f" ]]; then
    force=1
    shift
fi

if [[ "$1" == "-d" ]]; then
    digestOnly=1
    shift
fi


MARKERS_DIR=${MARKERS_DIR:-/tmp/etna-build-markers}
mkdir -p $MARKERS_DIR
Dockerfile=$1
baseTag=$(basename "$(dirname "$(realpath $Dockerfile)")")
tag="${IMAGES_PREFIX}${baseTag}${IMAGES_POSTFIX}"
marker=$MARKERS_DIR/$baseTag

if [[ -z "$Dockerfile" ]]; then
    usage
    exit 1
fi

shift

digest=
newestFile=$0
function addToDigest() {
     digest=$(echo $(cat -) $digest | md5sum | cut -d ' ' -f1)
}
function recursiveDigest() {
  if [[ -n "$digestOnly" ]]; then
     find "$1" -type f -exec md5sum {} \;
     echo
  fi
}
function findNewest() {
    lastModifiedFile=$(find $1 -printf "%T+ %p\n" | sort | tail -1 | cut -d ' ' -f2)
    if [ "$lastModifiedFile" -nt "$newestFile" ]; then
        newestFile="$lastModifiedFile"
     fi
}

# Handle any base image dependency
while read depImage; do
  baseDepImage=$depImage
  depImage="$DIR/$baseDepImage"
  if ! [[ -e "$depImage" ]]; then
    continue;
  fi
  recursiveDigest "$(realpath $depImage)" | addToDigest
  findNewest "$depImage"
  if [[ $newestFile -ot $MARKERS_DIR/$baseDepImage ]]; then
    newestFile=$MARKERS_DIR/$baseDepImage
  fi
done < <(cat $Dockerfile | xargs -n2 echo | cut -d ' ' -f2)

cat $0 | addToDigest

mounts="-v /var/run/docker.sock:/var/run/docker.sock:ro"
mounts="$mounts --mount type=bind,source=$(realpath $(dirname $Dockerfile)),target=/build/src"
recursiveDigest "$(dirname $Dockerfile)" | addToDigest
findNewest "$(dirname $Dockerfile)"

foundMounts=

while (( "$#" )); do
    if [[ "$1" == "--" ]]; then
      shift
      break
    fi

    # Dedup mounts
    if echo "$foundMounts" | grep "$(realpath "$1")" &>/dev/null; then
      shift
      continue
    fi

    foundMounts="$(realpath "$1")
$foundMounts"

    mounts="$mounts --mount type=bind,source=$(realpath $1),target=/build/$(basename $1)"
    recursiveDigest "$(realpath $1)" | addToDigest
    findNewest "$1"
    shift
done

if ! [[ -z "$onlyDigest" ]]; then
  echo "$Dockerfile $digest"
  exit 0
fi

if [[ -z "$force" && "$newestFile" -ot "$marker" ]]; then
  echo "Image $tag already up to date, skipping build"
  exit 0
fi

sleep 1

BUILD_CMD="cp src/.dockerignore . || true && docker build --rm --force-rm --tag $tag --cache-from $tag $* -f src/$(basename $Dockerfile) ."

set -x
docker image prune -f
docker run --rm -w /build $mounts docker:19.03.12 sh -c "$BUILD_CMD"
touch $marker
