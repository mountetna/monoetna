#! /usr/bin/env bash
set -e

prog=$0
error() {
   echo "Whoops!  Looks like $0:$2 failed."
   echo "Please try rerunning $prog again."
   exit 1
}
trap 'error "${BASH_SOURCE}" "${LINENO}"' ERR

SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" 
done
DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

function usage() {
  echo "$0 <Dockerfile> [<dep> [<dep2> ...]]" 1>&2
	cat $SOURCE | grep -E '^#-.*$$' | sed -e 's@^#- @  @' 1>&2
}

RED='\033[0;31m'
YELLOW='\033[1;33m'
CYAN='\033[1;36m'
NC='\033[0m'

if [[ "$1" == "-h" ]]; then
  usage
  exit 0
fi

#- Builds the given Dockerfile into an image,
#-   first by constructing a build directory that links together the shortest
#-   common parent directories of given dependencies, then running the given Dockerfile
#-   in that context.  It also injects metadata related to the release sha at the time
#-   the image is built.
Dockerfile=$1

#- The parent directory of the Dockerfile is used as the name of the image to be produced
#-   by this process, unless BASE_TAG is specified in the environment.
baseTag=${BASE_TAG:-$(basename "$(dirname "$(realpath $Dockerfile)")")}

#- The final tag will also include env variables IMAGES_PREFIX and IMAGES_POSTFIX
tag="${IMAGES_PREFIX}${baseTag}${IMAGES_POSTFIX}"

function imageExists() {
  docker inspect --type=image $tag &>/dev/null
}

if [[ -z "$Dockerfile" ]]; then
    usage
    exit 1
fi

shift

buildDir=$(mktemp -d)

sourceDockerDir="$(readlink -m $(dirname $Dockerfile))"
found=sourceDockerDir

ln -s "$(sourceDockerDir)" "$(buildDir)/src"
while (( "$#" )); do
    path="$(readlink -m $1)"
    if echo "$found" | grep "$path" &>/dev/null; then
      shift
      continue
    fi
    found="$path
$found"

    ln -s "$(readlink -m $1)" "$(buildDir)/$(basename $1)"
done

# Docker can 'leak' intermediate build images from different runs, unfortunately, even with --rm and --force-rm.
# This will atleast prune between runs to keep it minimal
[[ -z "$IS_CI" ]] && docker image prune -f

builtFromSha="$($DIR/find-parent-pr-merge.sh)"
# If we haven't pre-pulled the image, try pulling here.
# this might fail, however, especially for new or local tags.
if ! imageExists; then
  docker pull "$tag" || true
fi

# If we did manage to pull the image, pull out the existing built version info.
lastBuildId=
lastBuildVersion=
if imageExists; then
  lastBuildId="$(docker image inspect "$tag" | grep "\"Id\":" | sed -e 's/\s*//' | cut -d'"' -f4)"
  lastBuildVersion="$(docker image inspect "$tag" | grep "\"edu.ucsf.mountetna.version\":" | sed -e 's/\s*//' | tail -n 1 | cut -d'"' -f4)"
fi

set -x
cd "$buildDir"
cat $sourceDockerDir/.dockerignore /assist/.dockerignore | grep -v '#' | awk '{print \"src/\"\$0}' > .dockerignore
cp src/$(basename $Dockerfile) Dockerfile
echo >> Dockerfile
echo 'RUN true' >> Dockerfile
echo "COPY last.version /built-from-sha" >> Dockerfile
echo 'RUN true' >> Dockerfile

echo "$lastBuildVersion" > last.version


function runBuild() {
  docker build --rm --force-rm \
    --iidfile=next.id \
    --label=edu.ucsf.mountetna.version=$lastBuildVersion \
    --tag $baseTag \
    --cache-from etnaagent/$baseTag:staging \
    --cache-from $tag \
    --cache-from $baseTag \
    .
}

# Execute a base run.
runBuild

#- For images that are intended to be tagged and pushed to a repository, we'll want to rebuild
#  in the correct version labeling for this given commit, assuming that the built
#  id is differing.
if [[ "$baseTag" != "$tag" ]]; then
if [[ "$lastBuildId" != "$(cat next.id)" ]]; then
  lastBuildVersion="$builtFromSha"
  echo "$builtFromSha" > last.version
  runBuild
  docker tag $baseTag $tag
fi