#! /usr/bin/env bash
set -e

prog=$0
error() {
   echo "Whoops!  Looks like $0:$2 failed."
   echo "Please try rerunning $prog again."
   exit 1
}
trap 'error "${BASH_SOURCE}" "${LINENO}"' ERR

SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" 
done
DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

function usage() {
  echo "$0 <dir>" 1>&2
}

RED='\033[0;31m'
YELLOW='\033[1;33m'
CYAN='\033[1;36m'
NC='\033[0m'

dir=$(readlink -m $1)
touchTarget=$2
find=find
if type -p gfind; then
  find=gfind
fi

# when running tests in CI, only run tests for projects that have actually changed.
if ! [[ -z "$TARGET_ROOT_BRANCH" ]]; then
  # This is... so dumb.   git tooling will ---only work--- with,
  #   not relative paths
  #   not absolute paths
  #     absolutely relative to the current repository root, paths
  # which is a weird subset of paths which then break most assumptions in the makefiles
  # and build tools.
  # this comrpomise compromise forces us to the repository root to work
  # inside of the absolute relative paths and then prepends the actual
  # absolute path to the repository root before outputting that for normalization.
  dir="$(realpath --relative-to=$(git rev-parse --show-toplevel) $dir)"
  cd $(git rev-parse --show-toplevel)
  echo $(git rev-parse --show-toplevel)/$(git diff --name-only --relative $TARGET_ROOT_BRANCH $dir | tail -1)
  exit 0
fi

# By default in development, just track file modified times as the touched target
$find $dir -type f ! -path "*.marker" ! -path '*/node_modules/*' ! -path '*/.bundle/config' -printf "%T+ %p\n" | sort | tail -1 | cut -d ' ' -f2
