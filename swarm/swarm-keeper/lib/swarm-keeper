#!/usr/bin/env bash
set -eo pipefail
PORTAINER_HOST=${PORTAINER_HOST:-portainer.dsco.ucsf.edu}

if [ -n "$SOCKS" ]; then
  PROXY="--proxy=http:socks5h://$SOCKS --proxy=https:socks5h://$SOCKS"
fi
prog=$0
error() {
   echo "Whoops!  Looks like $1:$2 failed."
   echo "Please try rerunning $prog again."
   exit 1
}
trap 'error "${BASH_SOURCE}" "${LINENO}"' ERR


function doPortainerAuth() {
  set -eo pipefail
  local forceLogin=$1

  UN=
  PW=
  if [[ -f ~/.portainer-auth && -z "$forceLogin" ]]; then
    JWT=$(cat ~/.portainer-auth)
  else
    if [ -f /run/secrets/portainer-auth.env ]; then
      source /run/secrets/portainer-auth.env
    else
      read -e -p "Portainer username: " UN
      read -es -p "Portainer password: " PW
      echo
    fi

    JWT=$(http --ignore-stdin $PROXY POST https://${PORTAINER_HOST}/api/auth Username="${UN}" Password="${PW}" | tee >(cat 1>&2) | jq -r '.jwt')

    if ! [ -f /run/secrets/portainer-auth.env ]; then
      echo "$JWT" > ~/.portainer-auth
    fi
  fi
}

function doGithubAuth() {
  set -eo pipefail
  if [ -f /run/secrets/git-swarm-keeper-private-key ]; then
    mkdir -p ~/.ssh/
    ssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts
    cp /run/secrets/git-swarm-keeper-private-key ~/.ssh/id_rsa
  fi
}

function api() {
  set -eo pipefail
  verb="$1"
  shift
  path="$1"
  shift
  http --check-status $PROXY "$verb" https://${PORTAINER_HOST}/api${path} "Authorization: Bearer ${JWT}" "$@"
}

function dockerApi() {
  set -eo pipefail
  verb="$1"
  shift
  path="$1"
  shift
  api $verb /endpoints/$ENDPOINT/docker${path} "$@"
}

function listStacks() {
  set -eo pipefail
  api GET /stacks | jq -c '.[]'
}

function nonNull() {
  set -eo pipefail
  echo "$1" | jq --exit-status >/dev/null
}

function dig() {
  set -eo pipefail
  input="$1"
  shift
  echo "$input" | jq -c "$@"
}

function findStack() {
  set -eo pipefail
  stackId=$(api GET /stacks | jq  --arg n "$1" -c '.[] | select(.Name == $n) | .Id')

  if [[ -z "$stackId" ]]; then
    echo "Could not find stack $1" 1>&2
    echo "Found these: $(api GET /stacks | jq -r -c '.[] | .Name')" 1>&2
    return 1
  fi

  api GET /stacks/$stackId
}

function downloadStack() {
  set -eo pipefail
  tmp=$(mktemp)
  stack="$1"
  id="$(dig "$stack" -r '.Id')"

  api GET /stacks/$id/file | jq -r -c '.StackFileContent' > $tmp
  echo $tmp
}

function editsFile() {
  set -eo pipefail
  marker=$(mktemp)
  ${EDITOR:-vim} $1
  [[ $marker -ot $1 ]]
}

function mergeJson() {
  set -eo pipefail
  jq -n --argjson a "$1" --argjson b "$2" '$a * $b'
}

function concatJson() {
  set -eo pipefail
  jq -n --argjson a "$1" --argjson b "$2" '$a + $b'
}

function updateStackYml() {
  set -eo pipefail
  stack="$1"
  stackContent=${2:-}
  env=${3:-'[]'}

  endpoint="$(dig "$stack" -r '.EndpointId')"
  stackId="$(dig "$stack" -r '.Id')"

  if [[ -z "$stackContent" ]]; then
    stackContent="$(cat $(downloadStack "$stack"))"
  fi

  env=$(concatJson "$(dig "$stack" -r '.Env')" "$env")

  jq -c -n --argjson env "$env" --arg content "$stackContent" '{stackFileContent: $content, prune: true, env: $env}' | api PUT /stacks/$stackId?endpointId=$endpoint | jq
}

function servicesInStack() {
  set -eo pipefail
  stack="$1"
  name=$(dig "$stack" -r '.Name')
  filtersJson=$(jq -n -c --arg n $name '{label: ["com.docker.stack.namespace=" + $n]}')
  dockerApi GET /services "filters==$filtersJson" | jq -r -c '.[] | .Spec.Name'
}

function getResourceByName() {
  set -eo pipefail
  if [[ -z "$1" ]]; then
    echo "No $2 name given" 1>&2
    return 1
  fi
  if [[ -z "$2" ]]; then
    return 1
  fi

  filtersJson=$(jq -n -c --arg n $1 '{name: [$n]}')
  result="$(dockerApi GET /$2 "filters==$filtersJson" | jq -r -c '.[0]')"
  if nonNull "$result"; then
    echo "$result"
  else
    echo "Could not find $2 by name '$1'" 1>&2
    return 1
  fi
}

function getService() {
  set -eo pipefail
  getResourceByName "$1" "services"
}

function getConfig() {
  set -eo pipefail
  getResourceByName "$1" "configs"
}

function deleteConfig() {
  set -eo pipefail
  config=$(getResourceByName "$1" "configs" 2>/dev/null || echo null)
  if nonNull "$config"; then
    dockerApi DELETE /configs/$(dig "$config" -r '.ID') 1>/dev/null
  fi
}

function awaitServiceDeploy() {
  set -eo pipefail
  serviceName="$1"
  success=

  echo "Awaiting update to converge on $serviceName"

  for i in {0..60}
  do
    service=$(getService "$serviceName")
    filtersJson=$(jq -n -c --arg n $serviceName '{service: [$n], "desired-state": ["shutdown"]}')
    status=$(dig "$service" -r '.UpdateStatus.State')
    updateStartedAt=$(dig "$service" -r '.UpdateStatus.StartedAt // "0"')
    completed=$(dockerApi GET /tasks "filters==$filtersJson" | jq -c -r --arg sa "$updateStartedAt" '.[] | select(.CreatedAt >= $sa)')
    echo "$serviceName update is $status"

    case $status in
      completed|null)
        success=1
        break
        ;;
      paused)
        serviceState=

        while IFS=$'\n' read -r task; do
          serviceState=$(dig "$task" -r '.Status.State')
          if [[ "$serviceState" != "complete" ]]; then
            success=
            break
          fi

          success=1
        done <<< "$completed"

        break
        ;;
      rollback_completed|rollback_failed|rollback_started)
        break
        ;;
    esac
    sleep 3
  done

  if [[ "$success" == 1 ]]; then
    echo "Service finished deployment successfully"
    return 0
  fi

  echo "Service update was not successful"
  return 1
}

function awaitStackDeploy() {
  set -eo pipefail
  stack="$1"
  endpoint="$(dig "$stack" -r '.EndpointId')"
  stackId="$(dig "$stack" -r '.Id')"
  name="$(dig "$stack" -r '.Name')"
  services="$(servicesInStack "$stack")"

  echo "Awaiting stack '$name' services to converge..."

  for serviceName in $services; do
    awaitServiceDeploy $serviceName || true
  done
}

function downloadConfig() {
  set -eo pipefail
  tmp=$(mktemp)
  stack="$1"
  config="$(getConfig "$stack" "$2")"

  echo "$config" | jq -r '.Spec.Data | @base64d' > $tmp
  echo $tmp
}

function convergeConfigs() {
  for i in {0..60}; do
    c=$(findConvergeableConfig)
    if nonNull "$c"; then
      convergeConfig "$c"
    else
      break
    fi
  done
}

function findConvergeableConfig() {
  set -eo pipefail
  filtersJson=$(jq -n -c '{label: ["replaces="]}')
  dockerApi GET /configs "filters==$filtersJson" | jq 'sort_by(.UpdatedAt) | first'
}

function convergeConfig() {
  set -eo pipefail
  config="$1"
  configName="$(dig "$config" -r '.Spec.Name')"
  configData="$(dig "$config" -r '.Spec.Data')"
  configVersion="$(dig "$config" -r '.Version.Index')"
  configId="$(dig "$config" -r '.ID')"
  replaces="$(dig "$config" -r '.Spec.Labels.replaces')"
  bMode="$(dig "$config" '.Spec.Labels.bmode')"
  while true; do
    nextServiceUsingReplaces="$(dockerApi GET /services | jq --arg c "$replaces" \
      'map(select((.Spec.TaskTemplate.ContainerSpec.Configs // []) | map(.ConfigName) | index($c) >= 0)) | first')"
    if nonNull "$nextServiceUsingReplaces"; then
      serviceId=$(dig "$nextServiceUsingReplaces" -r '.ID')
      serviceName=$(dig "$nextServiceUsingReplaces" -r '.Spec.Name')
      version=$(dig "$nextServiceUsingReplaces" -r '.Version.Index')
      updatedConfigs=$(dig "$nextServiceUsingReplaces" --arg c "$replaces" --arg name "$configName" --arg id "$configId" \
        '.Spec.TaskTemplate.ContainerSpec.Configs | map(if .ConfigName == $c then (. * {ConfigName: $name, ConfigID: $id}) else . end)')
      nextServiceTaskTemplate=$(dig "$nextServiceUsingReplaces" '.Spec.TaskTemplate')
      updatedTaskTemplate=$(dig "$nextServiceTaskTemplate" --argjson c "$updatedConfigs" '. * {ContainerSpec: {Configs: $c}}')
      echo "Deploying $configName to $serviceName..."
      dockerApi POST /services/$serviceId/update \
        Name="$serviceName" \
        TaskTemplate:="$updatedTaskTemplate" \
        version=="$version" 1>/dev/null
      awaitServiceDeploy "$serviceName"
    else
      break
    fi
  done

  if ! nonNull "$bMode"; then
    # 'replaces' is now fully undeployed, we should remove it if it exists
    deleteConfig "$replaces"

    # If the process stops or fails here, on next entry the bmode config will be deleted
    # since it cannot be processed until after this config is deleted thanks to the sort by created at.

    createBmodeConfig "$configName" "$replaces" "$configData" 1>/dev/null
  fi

  updatedLabels="$(dig "$config" '.Spec.Labels | del(.replaces) | del(.bmode)')"

  dockerApi POST /configs/$configId/update \
    Name="$configName" \
    Labels:="$updatedLabels" \
    version=="$configVersion" 1>/dev/null
}

function resourceIdOf() {
  dig "$1" '.Portainer.ResourceControl.Id'
}

function withCopiedResourceControls() {
  set -eo pipefail
  original="$1"
  shift
  new="$("$@")"

  origResourceControl=$(dig "$original" '.Portainer.ResourceControl')
  newResourceId=$(resourceIdOf "$new")
  api PUT /resource_controls/$newResourceId \
    AdministratorsOnly:=$(dig "$origResourceControl" '.AdministratorsOnly') \
    Public:=$(dig "$origResourceControl" '.Public') \
    Teams:=$(dig "$origResourceControl" '.TeamAccesses') \
    Users:=$(dig "$origResourceControl" '.UserAccesses') 1>/dev/null

  echo "$new"
}

function createReplacementConfig() {
  set -eo pipefail
  original=$(getConfig "$1")
  origLabels=$(dig "$original" '.Spec.Labels // {}')
  labels=$(jq -n -c --argjson orig "$origLabels" --arg replaces "$1" '$orig * {"replaces": $replaces}')
  data=$(jq -r -n -c --arg content "$2" '$content | @base64')
  newConfigId=$(dockerApi POST /configs/create "Name=$1_$(date +"%s")" "Data=$data" "Labels:=$labels" | jq -r '.ID')
  withCopiedResourceControls "$original" dockerApi GET /configs/$newConfigId
}

function createBmodeConfig() {
  set -eo pipefail
  original=$(getConfig "$1")
  origLabels=$(dig "$original" '.Spec.Labels // {}')
  labels=$(jq -n -c --argjson orig "$origLabels" --arg replaces "$1" '$orig * {"replaces": $replaces, bmode: "true"}')
  newConfigId=$(dockerApi POST /configs/create "Name=$2" "Data=$3" "Labels:=$labels" | jq -r '.ID')
  withCopiedResourceControls "$original" dockerApi GET /configs/$newConfigId
}


function pushStackToRep() {
  set -eo pipefail
  stack="$1"
  name=$(dig "$stack" -r '.Name')
  id=$(dig "$stack" -r '.Id')
  gitConfig=$(dig "$stack" '.GitConfig')

  gitSourceMarker="/tmp/${name}.updated"
  mkdir -p /tmp/
  if ! [ -e "$gitSourceMarker" ] || [[ "$(date -r "$gitSourceMarker" +%s)" -lt "$(dig "$stack" '.UpdateDate')" ]]; then
    touch "$gitSourceMarker"
    if [[ "$(dig "$gitConfig" -r '.URL')" =~ https:\/\/github.com/([^.]*)\.git ]]; then
      repo="${BASH_REMATCH[1]}"
      if [[ "$(dig "$gitConfig" -r '.ReferenceName')" =~ refs\/heads\/(.*) ]]; then
        branch="${BASH_REMATCH[1]}"
        echo "Cloning..."
        git clone "git@github.com:${repo}.git" --branch "$branch" --single-branch . >/dev/null
        git config --global user.name "swarm-keeper"
        git config --global user.email "etnaagent@ucsf.edu"
        content="$(dig "$(api GET "/stacks/${id}/file")" -r '.StackFileContent')"
        path="$(dig "$gitConfig" -r '.ConfigFilePath')"
        echo "$content" > $path
        git add $path
        git commit -m "Updating $path from swarm-keeper"
        git push
      else
        false
      fi
    else
      false
    fi
  else
    echo "Skipping ${name}, already up to date."
  fi
}

function postToSlack() {
  set -eo pipefail
  post-to-slack "Swarm Keeper" "watchtower-ping" "$1"
}

function updateGitSources() {
  set -eo pipefail
  while IFS=$'\n' read -r stack; do
    echo "Processing $stack"
    name=$(dig "$stack" '.Name')
    gitConfig=$(dig "$stack" '.GitConfig')
    if nonNull "$gitConfig"; then
      dir=$(mktemp -d)
      cd $dir
      if ! pushStackToRep "$stack"; then
        postToSlack "Failed to push $name to $gitConfig"
      fi
      cd ..
      rm -rf $dir
    fi
  done <<< "$(listStacks)"
}

function runCommand() {
  set -eo pipefail
  cmd="$1"
  shift


  case "$cmd" in
    portainer-login)
      doPortainerAuth 1
      ;;
    portainer-client)
      doPortainerAuth
      api $@
      ;;
    portainer-edit-stack)
      doPortainerAuth
      stack=$(findStack "$1")
      tmp=$(downloadStack "$stack")
      if editsFile "$tmp"; then
        echo "Deploying changes to stack file"
        updateStackYml "$stack" "$(cat $tmp)"

        awaitStackDeploy "$stack"
      else
        echo "File was not modified, not deploying"
      fi
      ;;

    portainer-edit-config)
      doPortainerAuth
      tmp=$(downloadConfig "$1")
      cp $tmp ~/portainer-config-file
      if editsFile $tmp; then
        echo "Creating config..."
        createReplacementConfig "$1" "$(cat $tmp)"
        echo "Deploying config file change..."
        convergeConfigs
      else
        echo "File was not modified, not deploying"
      fi
  esac
}